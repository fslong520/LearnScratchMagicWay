# 程序逻辑及Scratch高级技能
## 1、Scratch的形象世界
### 1.1 简单运动控制

#### 1.1.1 运动的两种方式 坐标描述和面向描述
scratch的运动可以通过两种方式来控制：
    一个是直接告诉scratch，角色要移动到哪个坐标、哪个其他角色（的坐标）。我们称之为“上帝式移动”。
    另一个是在角色身上告诉角色重复执行往前移动，然后改变角色的方向。我们称之为“驾驶式移动”。
这两类运动方式使用的时候当然要按着场景来区别。顾名思义当我们想让角色直接移动到某位置时，就可以使用上帝式移动。而在代入游戏角色时，就要使用驾驶式移动了。

#### 1.1.2 偏心旋转和步进旋转
scratch的旋转运动可以用两种方法实现：
    一种就是设置角色的中心在图形的外侧或者外部，这时候我们让角色重复执行左转或者右转时，角色因为中心在外部从而看上去像角色在绕着某中心做圆周运动。
    另一种是让角色重复执行向前移动n步向左或向右转m角度。这种方式就好比祖冲之的割圆术将圆割成了多边形。因为是一步一步的旋转，我们将其称为步进旋转。

#### 1.1.3 高级的步进旋转讲解和三角函数计算公式
为了实现角色按着约定半径进行圆周运动，我们需要知道步进n和每步旋转角m还有圆周半径r之间的关系。初中几何告诉我们，r=n/2/sin(m/2)。在这里我们可以用一个自定义积木块来实现这个公式的计算，这里不用设置刷新屏幕也可以，因为这个自定义积木并没有包含重复执行等刷新屏幕的语句。这里我们实现了输入变量n和r来计算每步旋转角度，这样做的原因是因为我们常常需要控制步进来让运动看起来更加平滑，而角度不够直观，我们也很少去控制。
这个自定义积木还可以有很多应用，例如实现蛇形运动等，留给读者自己去实现。

#### 1.1.4 随机运动的实现
在计算机中我们应用的最多的就是随机，而在随机之上叠加的各种规则，可以让程序看起来更加的自然，甚至更加智能。前面几种基础运动，直线和曲线运动，我们可以给他们加上：
1. 随机的步进
2. 随机次数的步进（通过随机数和重复执行n次来实现）
3. 随机的角度
4. 随机的掉头，也即是随机乘以-1
5. 随机的游走，在一个变量x上不断叠加+1或者-1（不限制在+-1，什么数字都可以）。这样做可以实现一种游动的效果，在随机过程专业课之中称之为随机游走。

这五种基本的套路可以互相组合，形成很复杂的随机运动效果。

#### 1.1.5 撞墙了怎么办？回头和回头前冲
如果我们让一个角色随机的在舞台上乱晃，就像没头苍蝇一样。那么就有一个问题，角色撞墙了会发生什么？前面的内容已经说过，scratch是不允许任何角色的图案脱离舞台的。如果一个角色在随机的乱晃，撞墙了他也绝对不会脱离舞台，而且很可能会在舞台边上晃半天也不会回到舞台中心。这种情况很不美观，也不方便我们制作作品。
我们要使用一个判断来检测角色是否撞到了舞台边上，然后让角色回头，也就是重复执行判断角色碰到边界就反弹。但是前面疑难杂症部分也描述过，这个积木块是给初学者用的，存在很多不确定问题。最好使用侦测积木侦测到碰到边缘就旋转180度来的妥当，这里要注意的是，在旋转之后，角色仍旧有可能还碰到边缘，重复执行的检测又一次执行了180度翻转。看上去角色就在边界转来转去抖个不停。这也是常见的使用错误。
正确的做法是，在旋转180度积木后跟一句向前移动。这样在角色转身之后有一个前冲的效果，不至于再次碰到边缘。问题又来了，如果我们使用如下的积木来实现一个随机运动撞墙回头的角色，为什么回头前冲之后，角色还是会经常在墙边不肯回到中心呢？

######（这里用一个随机转向的例子）

我们来脑内设想一下这个过程，角色在一次循环之后有二分之一的概率会面向墙壁运动，我们应该让角色的转向随机的慢一些，这样看上去不会像没头苍蝇一样乱撞。这里我们通过一个随机10-20次的重复执行计数循环来实现控制角色移动方向，在碰到边界回头时，改变角色的方向变量减去180，使用增量来控制角色。可以观察到角色更像一个智慧生物在运动了。需要注意的是这种用增量来控制角色的思想，就是随机游走的思想，可以让角色的运动看上去不突兀。

######（更改代码）

#### 1.1.6 如何把随机运动物体限定在画面中间 幽灵追随
如果我们仍旧强迫症不可解，就是要一个速度很均匀的运动在舞台中央不会碰到墙壁的角色。该如何实现呢？
这里提供一种方案供大家思考：我们用两个角色，一个十分快速的随机移动，我们把它隐藏起来，起名叫做“幽灵”。另一个主角色，我们让他重复执行匀速运动，且每一次重复执行的时候都面向幽灵。因为幽灵速度极快的在舞台上飞动乱撞，而主角色只是方向在变化，而速度恒定。且因为是面向飞动的幽灵，方向变动也不是特别突兀。这样就实现了十分逼真的类生物移动效果。主角色会在舞台中央匀速但是偶尔转向的移动。
需要注意的是：幽灵本身因为隐藏起来了，他还可以通过碰撞边缘的侦测模块识别是否撞墙。在scratch之中，是否碰到边缘和是否碰到鼠标指针是两个特殊的判断，即时我们把角色隐藏起来，仍然可以使用。如果在后续版本的scratch之中这个功能产生了改变，还请读者自己设立一个变量来实时观察这个状态是否仍旧如此对于隐藏不敏感。
在文本语言之中，我们所熟知的是面向过程和面向对象两种编程模式。但是在scratch之中，我们其实是面向角色来编程更为方便。在幽灵追随这个例子之中，我们使用了一个幽灵跟随就省去了不少编写复杂随机逻辑的工作。后续也会有很多例子使用幽灵这一概念来帮助我们完成一些写在一个角色身上会很麻烦的事情。

#### 1.1.7 永远撞不到的物体 图章轨迹刷新
如果我们想做一个永远无法被碰撞到的角色，该如何实现呢？这里提供一个解决思路，我们将角色隐藏，在角色运动的重复执行之中开始将舞台画笔清空，角色移动之后，使用图章积木将角色画在画笔上。这样，别的角色再也不会误碰到该角色，而该角色也没有被隐藏消失，我们仍旧可以看到他的活动。
大家一定会问这样做的意义在哪里。原因是有时候我们为了某些互相产生复杂逻辑条件的碰撞（例如碰到角色 且 碰到红色 且 碰到别的角色不成立），这时候让一个角色不可触碰，逻辑条件会简约不少，不失为一个优雅的好方法。

### 1.2 画笔和运动结合的威力
1. 色轮和色环
2. 旋转和画笔结合
3. 斐波那契曲线
4. 彩虹旋涡
5. 闪电和雷暴
6. 画笔贪食蛇
7. 流星和星轨
8. 残影和运动轨迹绘制 抛射游戏
9. 递归分形图

### 1.3 外观控制和简单序列帧动画
1. 膨胀效果
2. 颜色等闪动效果
3. 序列帧动画制作和导入
4. 虚像隐藏的意义
5. 旋转和传送门效果

## 2、Scratch的抽象世界
### 2.1 变量可以实现那些事

1. 方便记录 变量计分 第一次应用
2. 方便调整 变量规定 步进 上线 血量等
3. 方便控制 变量控制角色属性
4. 方便逻辑 计数变量遍历列表
5. 方便存储 存储数据信息

变量作为几乎所有编程语言的最基础概念，是我们进入程序世界的时候最先要了解的。一般我们把变量解释为一个写了变量名的盒子，盒子里面装的东西被称之为数据，数据是可以被替换的，但是盒子还是盒子，只能装一个东西。例如装一个数字，装一个单词（字符串）等等。
在真实的计算机世界中，变量（寄存器变量除外）其实对应了内存之中的一个地址。内存就好比一个巨大无比的仓库。我们一旦命名了一个叫做a的变量，计算机就依照某种规则给我们的a分配了一个格子，然后把地址和变量名挂钩对应起来。当然地址是一串数字，我们人类不会喜欢看也记不住，我们就只要记住a就行了。
当我们把a删除掉，计算机就把分配的格子和a的对应关系忘记掉，以便下次继续分配给别的变量使用。
变量究竟有哪些作用，为什么几乎所有的编程语言都会有这个东西呢？

#### 2.1.1 方便记录

最直观的感觉是变量可以帮我们记录事情，例如记录游戏的得分，记录玩家的血量，记录敌人的数目，记录各种事情。说白了就是让电脑这个好脑子帮我们记住事。

#### 2.1.2 方便调整

我们可以用很多变量来实现各种复杂的功能，例如加分减分，规定血量上限，规定速度上限等等。这些事情往往是几个变量相互作用，一些用来记录，另一些变量则负责做出规定。在一些计算机语言之中，负责做出规定的这些不变的值，也被称之为“常量”，也即是恒常的量。
这时候我们一定很疑惑，数学之中的方程式我们很熟悉，3x+5=y，x和y是变量，5是常数量，为什么计算机里面5这种常量还要放在变量里面呢？
这里要注意：计算机和数学的概念不同，计算机所有的量本质上讲都是变量，即使是5这样的常数，即使是1000这种血量上限，即使是50这种速度上限。我们难保不会下次心血来潮给他改一个数值。所以计算机索性把所有的量都弄成了变量。请大家不要和数学的说法混淆。

#### 2.1.3 方便控制

我们在所有的游戏之中都会对人物做出很多属性的设定，例如血量多少，跑多快，攻击力如何等等。这时候我们经常使用一组变量来实现对人物的控制。这样的规定还有一种类似模板的功效，我们再创建别的人物也可以用这一套变量来描述。这样在设计时候会清晰不少。
在文本语言之中，我们常常听到一个说法是面向对象。究竟什么是面向对象呢？其实和刚说到的模板很类似，例如我们要给游戏设计100个怪物，他们的血量速度和攻击力都不一样。但是他们都有一些共性，因为我们用了同一套变量同一个模板来描述他们。这套模板就被称之为类（class）而每一个怪物拥有独一无二的变量数值，他们就被称之为类的一个实例。这就是面向对象的基础解释。

#### 2.1.4 方便逻辑

在后面的控制流中，我们常常使用变量来控制循环的逻辑。具体用法很简单，就好比用一个变量来帮我们计数，每次循环结束它就被加了1，而它从0开始就恰好是循环的一个编号。这种用法可以方便我们把数组的每一个元素按顺序拿出来。我们称这种方法为“遍历”。
也许我们会觉得这种遍历不是理所应当的，为什么还要单独的说呢？那么我们可以试验几个好玩的事情，例如把列表的所有偶数项拿出来求和，把列表的素数项求和。这时候我们就发现，一个技术的变量是多么的方便。

#### 2.1.5 方便存储

在计算机科学之中，我们常常把数据是如何存储的称之为“数据结构”。变量就是最简单的一个数据结构，列表是更加方便的一个数据结构，他把变量编号放在了一起，我们可以更加方便有序的使用这些变量。当然还有更加高级的一些数据结构，他们都有特定的用途。这些将在后文有所涉及。

### 2.2 布尔表达式和逻辑运算 另一种加减乘除
#### 2.2.1 布尔值和布尔
#### 2.2.1 布尔表达式和布尔运算（逻辑运算）
#### 2.2.2 真值表
#### 2.2.3 逻辑运算和条件分支嵌套的互相转换

### 2.3 列表-有序世界的基础
#### 2.3.1 列表和字典的区别
#### 2.3.2 列表存语言 聊天机器
#### 2.3.3 列表存随机 不重复随机列表
#### 2.3.4 列表存方向 贪食蛇 和重复蛇
#### 2.3.5 列表和字符串的异同

### 2.4 循环-批量化的天使
#### 2.4.1 循环100000次
#### 2.4.2 多重循环的意义 扫描屏幕
#### 2.4.3 数独游戏
#### 2.4.4 循环的展开 水仙花数
#### 2.4.5 循环fix
#### 2.4.6 循环监听
#### 2.4.7 循环刷新序列帧

### 2.5 计算机科学的发展史就是一部抽象史-函数
#### 2.5.1 循环的好朋友 函数 为了复用而抽象
#### 2.5.2 函数的参数 意义何在？ 更好的复用
#### 2.5.3 函数的刷新屏幕
#### 2.5.4 函数的嵌套
#### 2.5.5 拒绝长脚本 提倡并列式
#### 2.5.6 造好的轮子要不要重新造 Scratch的角色复用

### 3 抽象世界的深处
### 3.1 问题还没开始处理就已经被解决-递归
#### 3.1.1 递归三要素 递归方式 停止条件 逻辑不重叠 德罗斯特效应 谷歌递归
#### 3.1.2 递归和顺序的区别 阶乘 最大公约数 首先假设问题已经被解决
#### 3.1.3 分型和递归 科赫雪花 H树 随机树 蕨类植物 龙形曲线 C形曲线
#### 3.1.4 汉诺塔和二进制三进制
#### 3.1.5 斐波那契和兔子
#### 3.1.6 树遍历

### 3.2 排序和查找-有序和贪婪
#### 3.2.1 排序的八种姿势
#### 3.2.2 排序算法的复杂度
#### 3.2.3 排序算法的使用场景
#### 3.2.4 查找的七种武器
#### 3.2.5 查找长度和应用场景

### 3.3 避免耦合-队列
#### 3.3.1 良好秩序从排队抓起 队列的意义
#### 3.3.2 如果有有限级更高的特权怎么办？ 优先队列和堆
#### 3.3.3 网络资源分配和CPU资源分配

### 3.4 堆栈和树的关系
#### 3.4.1 为什么要后入先出？从摊开的书本开始
#### 3.4.2 函数递归的堆栈表示
#### 3.4.3 递归-树和堆栈
#### 3.4.4 屏幕跳转
#### 3.4.5 带优先级的计算器

### 3.5 降维打击 二维数组的实现
#### 3.5.1 二维数组的本质是一维数组
#### 3.5.2 舞台空间也可以是一种存储？存储只是一种思想
#### 3.5.3 多维数组怎么办？
#### 3.5.4 二维数组和平面的连续地形绘制

### 3.6 上知天文下知地理的预测-回归
### 3.6.1 真实世界的偏差 线性回归
### 3.6.2 回归核心和预测

### 3.7 风险-加锁和竞争
#### 3.7.1 竞争的本质是时序规则
#### 3.7.2 敌人的竞争 你更新我刷新
#### 3.7.3 自己和自己的竞争 按键瞬间多次激发
#### 3.7.4 时序图 上升沿和下降沿控制 正锁反锁
#### 3.7.5 蓄力和打断
#### 3.7.6 格斗游戏的硬直和解除
#### 3.7.7 连招系统和时序控制

### 3.8 从开关到王者荣耀-计算机组成
#### 3.8.1 计算机的原子 二值电路和开关 为什么不搞三值电路
#### 3.8.2 三极管推拉制造逻辑门电路
#### 3.8.3 逻辑门电路到锁存器 如何存下01000101010
#### 3.8.4 锁存器到加法器 实现基本计算
#### 3.8.5 计算机结构和CPU指令集
#### 3.8.6 驱动和操作系统
#### 3.8.7 软件和通讯
#### 3.8.8 互联网、云计算和区块链