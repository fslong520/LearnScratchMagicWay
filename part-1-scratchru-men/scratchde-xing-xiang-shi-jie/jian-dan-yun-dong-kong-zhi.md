1. 直线运动的两种方式 坐标描述和面向描述
2. 偏心旋转和步进旋转 
3. 高级的步进旋转讲解和三角函数计算公式
4. 随机运动的实现
5. 撞墙了怎么办？回头和回头前冲
6. 如何把随机运动物体限定在画面中间 幽灵追随
7. 永远撞不到的物体 图章轨迹刷新


# 1. 运动的两种方式 坐标描述和面向描述
scratch的运动可以通过两种方式来控制：
    一个是直接告诉scratch，角色要移动到哪个坐标、哪个其他角色（的坐标）。我们称之为“上帝式移动”。
    另一个是在角色身上告诉角色重复执行往前移动，然后改变角色的方向。我们称之为“驾驶式移动”。
这两类运动方式使用的时候当然要按着场景来区别。顾名思义当我们想让角色直接移动到某位置时，就可以使用上帝式移动。而在代入游戏角色时，就要使用驾驶式移动了。

# 2. 偏心旋转和步进旋转
scratch的旋转运动可以用两种方法实现：
    一种就是设置角色的中心在图形的外侧或者外部，这时候我们让角色重复执行左转或者右转时，角色因为中心在外部从而看上去像角色在绕着某中心做圆周运动。
    另一种是让角色重复执行向前移动n步向左或向右转m角度。这种方式就好比祖冲之的割圆术将圆割成了多边形。因为是一步一步的旋转，我们将其称为步进旋转。

# 3. 高级的步进旋转讲解和三角函数计算公式
为了实现角色按着约定半径进行圆周运动，我们需要知道步进n和每步旋转角m还有圆周半径r之间的关系。初中几何告诉我们，r=n/2/sin(m/2)。在这里我们可以用一个自定义积木块来实现这个公式的计算，这里不用设置刷新屏幕也可以，因为这个自定义积木并没有包含重复执行等刷新屏幕的语句。这里我们实现了输入变量n和r来计算每步旋转角度，这样做的原因是因为我们常常需要控制步进来让运动看起来更加平滑，而角度不够直观，我们也很少去控制。
这个自定义积木还可以有很多应用，例如实现蛇形运动等，留给读者自己去实现。

# 4. 随机运动的实现
在计算机中我们应用的最多的就是随机，而在随机之上叠加的各种规则，可以让程序看起来更加的自然，甚至更加智能。前面几种基础运动，直线和曲线运动，我们可以给他们加上：
#### 1随机的步进
#### 2随机次数的步进（通过随机数和重复执行n次来实现）
#### 3随机的角度
#### 4随机的掉头，也即是随机乘以-1
#### 5随机的游走，在一个变量x上不断叠加+1或者-1（不限制在+-1，什么数字都可以）。这样做可以实现一种游动的效果，在随机过程专业课之中称之为随机游走。
这五种基本的套路可以互相组合，形成很复杂的随机运动效果。

# 5. 撞墙了怎么办？回头和回头前冲
如果我们让一个角色随机的在舞台上乱晃，就像没头苍蝇一样。那么就有一个问题，角色撞墙了会发生什么？前面的内容已经说过，scratch是不允许任何角色的图案脱离舞台的。如果一个角色在随机的乱晃，撞墙了他也绝对不会脱离舞台，而且很可能会在舞台边上晃半天也不会回到舞台中心。这种情况很不美观，也不方便我们制作作品。
我们要使用一个判断来检测角色是否撞到了舞台边上，然后让角色回头，也就是重复执行判断角色碰到边界就反弹。但是前面疑难杂症部分也描述过，这个积木块是给初学者用的，存在很多不确定问题。最好使用侦测积木侦测到碰到边缘就旋转180度来的妥当，这里要注意的是，在旋转之后，角色仍旧有可能还碰到边缘，重复执行的检测又一次执行了180度翻转。看上去角色就在边界转来转去抖个不停。这也是常见的使用错误。
正确的做法是，在旋转180度积木后跟一句向前移动。这样在角色转身之后有一个前冲的效果，不至于再次碰到边缘。问题又来了，如果我们使用如下的积木来实现一个随机运动撞墙回头的角色，为什么回头前冲之后，角色还是会经常在墙边不肯回到中心呢？
######（这里用一个随机转向的例子）
我们来脑内设想一下这个过程，角色在一次循环之后有二分之一的概率会面向墙壁运动，我们应该让角色的转向随机的慢一些，这样看上去不会像没头苍蝇一样乱撞。这里我们通过一个随机10-20次的重复执行计数循环来实现控制角色移动方向，在碰到边界回头时，改变角色的方向变量减去180，使用增量来控制角色。可以观察到角色更像一个智慧生物在运动了。需要注意的是这种用增量来控制角色的思想，就是随机游走的思想，可以让角色的运动看上去不突兀。
######（更改代码）

# 6. 如何把随机运动物体限定在画面中间 幽灵追随
如果我们仍旧强迫症不可解，就是要一个速度很均匀的运动在舞台中央不会碰到墙壁的角色。该如何实现呢？
这里提供一种方案供大家思考：我们用两个角色，一个十分快速的随机移动，我们把它隐藏起来，起名叫做“幽灵”。另一个主角色，我们让他重复执行匀速运动，且每一次重复执行的时候都面向幽灵。因为幽灵速度极快的在舞台上飞动乱撞，而主角色只是方向在变化，而速度恒定。且因为是面向飞动的幽灵，方向变动也不是特别突兀。这样就实现了十分逼真的类生物移动效果。主角色会在舞台中央匀速但是偶尔转向的移动。
需要注意的是：幽灵本身因为隐藏起来了，他还可以通过碰撞边缘的侦测模块识别是否撞墙。在scratch之中，是否碰到边缘和是否碰到鼠标指针是两个特殊的判断，即时我们把角色隐藏起来，仍然可以使用。如果在后续版本的scratch之中这个功能产生了改变，还请读者自己设立一个变量来实时观察这个状态是否仍旧如此对于隐藏不敏感。
在文本语言之中，我们所熟知的是面向过程和面向对象两种编程模式。但是在scratch之中，我们其实是面向角色来编程更为方便。在幽灵追随这个例子之中，我们使用了一个幽灵跟随就省去了不少编写复杂随机逻辑的工作。后续也会有很多例子使用幽灵这一概念来帮助我们完成一些写在一个角色身上会很麻烦的事情。

# 7. 永远撞不到的物体 图章轨迹刷新
如果我们想做一个永远无法被碰撞到的角色，该如何实现呢？这里提供一个解决思路，我们将角色隐藏，在角色运动的重复执行之中开始将舞台画笔清空，角色移动之后，使用图章积木将角色画在画笔上。这样，别的角色再也不会误碰到该角色，而该角色也没有被隐藏消失，我们仍旧可以看到他的活动。
大家一定会问这样做的意义在哪里。原因是有时候我们为了某些互相产生复杂逻辑条件的碰撞（例如碰到角色 且 碰到红色 且 碰到别的角色不成立），这时候让一个角色不可触碰，逻辑条件会简约不少，不失为一个优雅的好方法。


