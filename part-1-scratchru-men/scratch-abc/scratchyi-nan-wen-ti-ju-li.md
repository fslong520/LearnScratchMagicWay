由于Scratch是一款面向少儿的编辑器，为了避免儿童的随意使用造成软件崩溃，引入了许多不够完善的特性。刚接触时往往会陷入一些奇怪的疑难问题之中。本章将会从以下几个方面介绍日常使用Scratch会碰到的边角问题：

1. 绘图和外观的坑
2. 看不见摸不着的事件控制
3. 不知道该用什么变量的克隆体
4. Scratch的谜之容错
5. 拖慢脚本的罪魁祸首

# 1. 绘图和外观的坑

1. 任何图片都不能离开舞台
2. 矢量图和位图切边
3. 角色和克隆体的复杂层级关系
4. 默认角度90°
5. 消失的几种姿势

#### 任何角色都不能离开舞台

为了防止不小心把角色移动出舞台找不到，scratch做了几个限制。首先任何角色在移动到舞台边缘的时候会强制留下一个边缘，刚好可以用鼠标拖拽它回到舞台之中。例如我们使用坐标移动积木让某角色移动到x1000,y0。这样角色实际上的x坐标在250多就已经卡住了，刚好在舞台上漏了一个角。

对于角色的限制不光在于位置，还包括了角色的外观大小。我们让角色大小设定为极大例如1000，在外观积木盒子最下方的大小变量之上用鼠标勾选之后，可以观察到，角色根本没有变成1000，而是卡在了几百就不在增加。

相应的，如果我们给角色设定一个1的大小甚至-1000的大小，角色大小就被锁定成了5。这是为了防止角色太小无法画在舞台上。

理解了scratch的这个角色不能离开舞台的机制之后，我们就可以考虑一些问题。如果想让一个克隆体从画面外移动进画面，这个动作可以做到么？答案是不能。因为角色一旦设置一个画面外的位置，scratch就会强制把角色的一个小角拉到舞台上，这样画面边界一定会留一点角色。根本无法让角色完全从舞台外移入舞台。

###### 图 不能完全从舞台外移动进舞台

如果我们一定要让角色从舞台外移动进舞台，就要把入口这个边界用一个不透明的角色遮盖住。这样在视觉效果中，就看不到这里的异常了。例如我们想用scratch做一个横版卷轴游戏，类似超级马里奥。地图的卷动就需要从舞台外移动进来，这时候就需要把边界遮住防止玩家看到这里堆了奇怪的东西。

#### 矢量图和位图切边

首先要界定什么是矢量图什么是标量图（位图）。我们做如下界定：

1. 矢量图是指软件自己知道如何可以画出来的图，可以一条线一条线的画出来
2. 标量图是软件只拿到了一副画，这幅画被毁掉了软件也不会补充回来了

关于矢量和标量的定义和意义大家如果有兴趣请参看part3的数学概念

scratch对于外形自带了两种编辑模式可以互相切换，不过非常不建议各位读者使用这些编辑功能，因为十分不完善的编辑功能影响体验。这里要强调的是几个原则：

1. 从本地导入的图片，即时原来是所谓的“矢量图”格式，例如png等。导入scratch之后也默认变成了一个位图，因为它并不是scratch自己画的
2. scratch承认的矢量图，只有两类。一类是造型之中切换矢量图编辑模式自己绘制的图片，另一类是scratch角色库之中自带的角色
3. scratch承认的矢量图在造型之中编辑。如果不小心被我们在编辑中移动出画布，还可以移动回来。但是本地导入的图片如果不小心移动出编辑画面就会发生切割丢失现象。

###### 图 本地导入图片在选择中心的时候发生切割丢失现象

为什么会发生切割丢失现象呢？原因是图片移出了编辑区之后都会发生切割，但是矢量图scratch知道怎么画回来，而位图scratch不知道怎么画于是就丢失了。如何避免这个情况发生呢？这里我们要首先使用位图编辑的选择工具选中图片的主要内容，通过缩放和拖拽来设置图片中心。防止在操作过程中让图片移出编辑区，这样就不会发生切割丢失现象了。

###### 图 如何避免设置中心时候发生切割丢失现象

#### 角色和克隆体的复杂层级关系

在scratch之中有一种复杂的层级关系和管理原则

1. 角色在舞台上被拖拽就会默认移到顶层。
2. 舞台无论如何都在最下层，画笔和图章都会绘制在舞台上。换句话说任何不透明角色都可以挡住画笔和图章。
3. 任何新创建的角色都会默认移到顶层。
4. 角色的克隆体默认在角色下一层。
5. 角色再次克隆的克隆体再角色和前一个克隆体之间。因为首先它是新生成的物体放在最顶层，其次执行角色本体在克隆体之上的操作。

###### 图 角色和克隆体层级关系

# 2. 看不见摸不着的事件控制

1. 鼠标点绿旗的迷惑
2. 消息等待
3. 等待0秒？等待-1秒？最小等待时间是多少0.033平均
4. 藏起来就不刷新屏幕的列表和变量 没有anyone刷新屏幕就飞快
5. 死循环嵌套的后果
6. 计数循环变计数能否进行
7. 拖拽优先级最高
8. 并行的条件竞争 碰到边缘反弹和等待碰到边缘
9. 真实时间的获取

#### 鼠标点绿旗的迷惑

在scratch之中，绿旗是我们最常使用的入口。但是如果我们让角色在鼠标按下的时候做出一些动作（例如发射子弹），这时候问题就来了。一旦我们点击绿旗开始还没准备好真正开枪，scratch会马上发射一个子弹。这是因为scratch在绿旗入口的瞬间抓到了鼠标按下的事件。为了解决这个怪异的行为，我们必须使用一个称之为锁的东西。
scratch给我们提供了很方便的实现锁的工具，那就是“等到直到”积木。我们只需要在绿旗入口下跟一句：等到直到鼠标键按下不成立。这样在我们点击绿旗之后，程序会等待直到我们把鼠标键松开，才继续向下运行。就好像一个锁把程序运行的脚步锁住。这个概念我们将会在后文经常用到。
在真正的文本语言之中，锁的实现是用变量记录状态做的。这种方法略显复杂。在scratch之中经常使用的就是等待直到积木。

###### 绿旗点击锁
###### 变量锁

#### 消息等待

在scratch之中，我们经常会接触到消息发送接受。最常见的错误就是在消息等待过程之中使用死循环。“广播消息并等待”积木将会等待所有的消息接收者执行完毕，如果有一个接受者身上带有一个死循环重复执行。那么它将永远无法执行完毕，广播消息并等待的积木也将天长地久的等下去无法继续运行后面的内容。

#### 等待0秒？等待-1秒？最小等待时间是多少0.033平均

在scratch之中我们最容易搞不清楚的就是等待1秒积木。其实等待积木和任何重复执行积木都在一次运行或者一次循环之后会将运行时间补充到0.33秒。如果我们将等待积木写等待0秒或者等待-1秒，再测量其运行时间，结果都将是0.33秒左右。

###### 等待0秒

#### 藏起来就不刷新屏幕的列表和变量 没有anyone刷新屏幕就飞快

是不是scratch的所有重复执行都会补充时间到0.33秒呢？这里是有例外的。
如果我们把重复执行之中只放一个操作列表的语句，例如加入一个元素。然后我们先将列表隐藏，点击绿旗运行大约1秒时我们打开列表显示观察会发现，列表的元素有好几十万。这是因为重复执行积木中没有任何要刷新屏幕的积木，所以默认全速运行，也不会补充时间。
如果我们把列表显示出来，这时候再运行，发现列表元素增加的过程慢了许多。这是因为列表的显示和更新就是刷新屏幕的动作，重复执行积木会补充时间。

###### 列表和重复执行刷新屏幕

#### 死循环嵌套的后果

新手经常犯的错误还包括死循环嵌套死循环。外层的死循环运行第一次的时候就进入了内层的死循环，从此陷入了内层的死循环再也无法出来。也就是说，外层循环变成了一个摆设，因为就运行了一次根本不会循环。请大家一定要注意。

###### 死循环嵌套

#### 计数循环变计数能否进行

假如我们用一个变量来控制计数循环，如果这个变量在循环之中被改变了，那么循环次数会动态的改变么？答案是，不会。计数循环在第一次运行时就已经被锁定了运行次数，无论我们怎么改这个变量，循环次数是不会发生改变的。这是为了防止出现一些运行错误。

###### 变量控制计数循环

#### 拖拽优先级最高

在scratch的编辑模式（就是平常的模式，相对于全屏播放模式来说的），运行程序时，拖拽的优先级是高于点击判断的。如果我们程序中设定了点击角色之后有一些操作，那么点击角色之后会首先把角色拖拽起来，而不是执行这些操作。
假如我们要做一个画笔，点击鼠标之后落笔开始画。点击画笔之后首先会拖拽起来画笔图案，而不是首先落笔。

###### 画笔和拖拽

解决这样的问题有两个办法，第一个是永远在播放模式下运行，且不去勾选播放模式可以拖动的选项，这样就不会出现拖动的情况。第二种是将画笔图案的中心设置在图案外，这样在点击和移动到鼠标时，鼠标不会碰到图案，从而不会产生拖拽。巧妙地解决问题。

###### 图案中心设置解决拖拽问题

#### 并行的条件竞争 碰到边缘反弹和等待碰到边缘

在scratch之中，每一个程序入口下的脚本都是并行的。这样就会产生竞争，如果两个并行的脚本同时操纵一个角色，就会改来改去发生错误。例如我们在角色身上写两个脚本，一个让角色重复执行移动，碰到边缘就反弹。另一个脚本重复执行判断是否碰到边缘，碰到边缘就让角色说：“碰到边缘”。
这样的运行，偶尔角色会说碰到边缘，偶尔不会说。就是因为发生了竞争，碰到边缘的时候：A）如果碰到边缘反弹的积木先执行，角色脱离了边缘才进行碰到边缘检测说话，这时候不会说话。B)如果碰到边缘检测说话先执行，那么角色就会说话。
A和B两种情况我们并不知道哪个会先发生，这就是并发竞争。
需要注意的是，这种竞争产生的bug偶尔会出现偶尔不会出现，十分难以察觉，属于最难搞定的bug之一。

###### 并发竞争脚本

#### 真实时间的获取

在scratch之中，有许多和时间有关的积木，我们来看一下他们之间的区别。

1. 等待1秒积木
2. 计时器
3. 自2000年至今的天数

最不准确的积木就是等待1秒，前面我们已经说过，该积木会带来三十分之一秒的刷新延迟。本身也不适合记录精确时间。
计时器看上去比等待1秒积木靠谱的多，但是依旧有一个问题，如果我们的程序有些庞大，运行速度整体变慢，计时器也会变得很卡，这时候时间也不做准。
最准确的时间是自2000年至今的天数，这个积木块用的是计算机时间，我们把这个积木乘以100000，就会得到秒级别的真实时间。当然我们可以获得更小的时间分辨率，但是意义不大。请大家自己探索。


# 3. 不知道该用什么变量的克隆体

1. 私有变量和私有改动
2. 消息入口的继承
3. 使用消息指数克隆
4. 网格锁定和抓取集中
5. 克隆体整理
6. 克隆体克隆别的克隆体的队列设置 

scratch的克隆体是不大容易理解的概念，其中经常使用的一些私有和公有变量的概更是抽象。下面我们来例举一些常见的使用方法。

#### 私有变量和私有改动

在克隆体之中，我们为了独立控制每个克隆体，经常会给克隆体设置私有变量。实际上我们是把私有变量设置在母体身上，当克隆动作执行时，克隆体身上也复制了这个私有变量，但是这个私有变量就是属于克隆体的，和母体再无关系。

实际上克隆会复制以下事情：

1.母体角色当前的外观造型
2.母体角色当前的位置坐标
3.母体身上全部的脚本
4.母体身上全部的私有变量和私有列表

前两条容易理解，第三条说克隆体复制了母体的全部脚本，那么当作为克隆体启动这个入口的意义在哪里？
其实克隆体也复制了母体身上当绿旗被点击入口的脚本，只是绿旗这时候没有被点击所以不满足这个入口条件不会运行，而作为克隆体启动入口这时候刚好满足条件可以运行。
如果母体身上带有一些消息入口，克隆体同样会复制下来，当消息广播时同样可以运行。我们可以通过消息来控制克隆体。
第四条说母体身上全部的私有变量和私有列表。那么公有的呢？答案是公有的不需要刻意复制，谁都可以自由使用。而私有变量如果不复制，在别的角色身上是看不到没法用的。

另一个关键的事情是：积木盒子之中角色的xy坐标、方向、造型编号等可以打钩显示的变量，全都默认是私有变量。请大家注意区分，私有变量显示时有“XXX：变量名”，而公有变量只有变量名。

#### 消息入口的继承

刚才提到了克隆体可以复制母体的消息入口，这个机制可以很方便的实现克隆体的控制。例如我们要某个消息可以把所有的克隆体清除掉，那么简单的在母体身上写下脚本：接收到消息删除本克隆体，这样就可以做到。
这里的消息可以帮我们实现许多集体效果。例如我们想通过一个消息让所有的克隆体震动一下，做出一个炫酷的效果。我们可以让消息入口下跟一个x坐标增加-20，等待0.1秒后x坐标增加20。其他用法请大家自己探索。

###### 消息入口清除和震动效果

#### 使用消息指数克隆

如果我们想通过很少的代码大量的克隆角色，常用的方法有：

1.重复执行+克隆某角色（运行速度慢有卡顿感）
2.把重复执行+克隆做成一个运行时不刷新屏幕的自定义积木
3.让克隆体克隆自己

这里主要说一下第三个方法。学过幂指数就应该知道。如果我们让克隆体作为克隆体产生时克隆自己，克隆体将会以2的指数来增长。scratch为了防止克隆体太多拖慢速度，会限制同时存在的角色总数目为300个。

我们还可以用消息来控制角色的克隆过程，为了区分克隆出来的人，我们让本体接收到消息时右转移动并克隆自己，让克隆体启动时向左移动。这样克隆体也继承了这个消息入口，再次发送这个消息时，刚才的克隆体也会分裂出下一代的克隆体。

###### 二叉树克隆

#### 网格锁定和抓取集中

如果我们想让克隆体在播放时可以被拖动，但是放开鼠标按键的时候我们想让角色固定在我们约定的网格上。例如我们想做一个拼图，希望拖拽放手时拼图块可以自动对齐。
这时候我们就要用坐标取整的方法了。首先打开角色的播放时可以被拖动开关，然后在克隆体身上加上取整移动。

###### 坐标取整



# 4. Scratch的谜之容错

1. 不写入数字是计算多少
2. 写入小数的列表提取
3. 造型编号0的问题 颜色和角度的小于零
4. 不写入与或非结果是什么
5. 积木空缺填补参数的强大容错 面向角色的积木块可以加入数字 其实是可以加入字符串来实现
6. 利用容错能做什么 字符\*1等于0 用来判断回答是否为字符 利用数字当成字符串抽出其中的第几位

# 5. 拖慢脚本的罪魁祸首

1. 特效加循环
2. 外形复杂多角色移动



