由于Scratch是一款面向少儿的编辑器，为了避免儿童的随意使用造成软件崩溃，引入了许多不够完善的特性。刚接触时往往会陷入一些奇怪的疑难问题之中。本章将会从以下几个方面介绍日常使用Scratch会碰到的边角问题：

1. 绘图和外观的坑
2. 看不见摸不着的事件控制
3. 不知道该用什么变量的克隆体
4. Scratch的谜之容错
5. 拖慢脚本的罪魁祸首

# 1. 绘图和外观的坑

1. 任何图片都不能离开舞台
2. 矢量图和位图切边
3. 角色和克隆体的复杂层级关系
4. 默认角度90°
5. 消失的几种姿势

#### 任何角色都不能离开舞台

为了防止不小心把角色移动出舞台找不到，scratch做了几个限制。首先任何角色在移动到舞台边缘的时候会强制留下一个边缘，刚好可以用鼠标拖拽它回到舞台之中。例如我们使用坐标移动积木让某角色移动到x1000,y0。这样角色实际上的x坐标在250多就已经卡住了，刚好在舞台上漏了一个角。

对于角色的限制不光在于位置，还包括了角色的外观大小。我们让角色大小设定为极大例如1000，在外观积木盒子最下方的大小变量之上用鼠标勾选之后，可以观察到，角色根本没有变成1000，而是卡在了几百就不在增加。

相应的，如果我们给角色设定一个1的大小甚至-1000的大小，角色大小就被锁定成了5。这是为了防止角色太小无法画在舞台上。

理解了scratch的这个角色不能离开舞台的机制之后，我们就可以考虑一些问题。如果想让一个克隆体从画面外移动进画面，这个动作可以做到么？答案是不能。因为角色一旦设置一个画面外的位置，scratch就会强制把角色的一个小角拉到舞台上，这样画面边界一定会留一点角色。根本无法让角色完全从舞台外移入舞台。

###### 图 不能完全从舞台外移动进舞台

如果我们一定要让角色从舞台外移动进舞台，就要把入口这个边界用一个不透明的角色遮盖住。这样在视觉效果中，就看不到这里的异常了。例如我们想用scratch做一个横版卷轴游戏，类似超级马里奥。地图的卷动就需要从舞台外移动进来，这时候就需要把边界遮住防止玩家看到这里堆了奇怪的东西。

#### 矢量图和位图切边

首先要界定什么是矢量图什么是标量图（位图）。我们做如下界定：

1. 矢量图是指软件自己知道如何可以画出来的图，可以一条线一条线的画出来
2. 标量图是软件只拿到了一副画，这幅画被毁掉了软件也不会补充回来了

关于矢量和标量的定义和意义大家如果有兴趣请参看part3的数学概念

scratch对于外形自带了两种编辑模式可以互相切换，不过非常不建议各位读者使用这些编辑功能，因为十分不完善的编辑功能影响体验。这里要强调的是几个原则：

1. 从本地导入的图片，即时原来是所谓的“矢量图”格式，例如png等。导入scratch之后也默认变成了一个位图，因为它并不是scratch自己画的
2. scratch承认的矢量图，只有两类。一类是造型之中切换矢量图编辑模式自己绘制的图片，另一类是scratch角色库之中自带的角色
3. scratch承认的矢量图在造型之中编辑。如果不小心被我们在编辑中移动出画布，还可以移动回来。但是本地导入的图片如果不小心移动出编辑画面就会发生切割丢失现象。

###### 图 本地导入图片在选择中心的时候发生切割丢失现象

为什么会发生切割丢失现象呢？原因是图片移出了编辑区之后都会发生切割，但是矢量图scratch知道怎么画回来，而位图scratch不知道怎么画于是就丢失了。如何避免这个情况发生呢？这里我们要首先使用位图编辑的选择工具选中图片的主要内容，通过缩放和拖拽来设置图片中心。防止在操作过程中让图片移出编辑区，这样就不会发生切割丢失现象了。

###### 图 如何避免设置中心时候发生切割丢失现象

#### 角色和克隆体的复杂层级关系

在scratch之中有一种复杂的层级关系和管理原则

1. 角色在舞台上被拖拽就会默认移到顶层。
2. 舞台无论如何都在最下层，画笔和图章都会绘制在舞台上。换句话说任何不透明角色都可以挡住画笔和图章。
3. 任何新创建的角色都会默认移到顶层。
4. 角色的克隆体默认在角色下一层。
5. 角色再次克隆的克隆体再角色和前一个克隆体之间。因为首先它是新生成的物体放在最顶层，其次执行角色本体在克隆体之上的操作。

###### 图 角色和克隆体层级关系

# 2. 看不见摸不着的事件控制

1. 鼠标点绿旗的迷惑
2. 消息等待
3. 等待0秒？等待-1秒？最小等待时间是多少0.033平均
4. 藏起来就不刷新屏幕的列表和变量 没有anyone刷新屏幕就飞快
5. 死循环嵌套的后果
6. 计数循环变计数能否进行
7. 拖拽优先级最高
8. 并行的条件竞争 碰到边缘反弹和等待碰到边缘
9. 真实时间的获取

#### 鼠标点绿旗的迷惑

在scratch之中，绿旗是我们最常使用的入口。但是如果我们让角色在鼠标按下的时候做出一些动作（例如发射子弹），这时候问题就来了。一旦我们点击绿旗开始还没准备好真正开枪，scratch会马上发射一个子弹。这是因为scratch在绿旗入口的瞬间抓到了鼠标按下的事件。为了解决这个怪异的行为，我们必须使用一个称之为锁的东西。
scratch给我们提供了很方便的实现锁的工具，那就是“等到直到”积木。我们只需要在绿旗入口下跟一句：等到直到鼠标键按下不成立。这样在我们点击绿旗之后，程序会等待直到我们把鼠标键松开，才继续向下运行。就好像一个锁把程序运行的脚步锁住。这个概念我们将会在后文经常用到。
在真正的文本语言之中，锁的实现是用变量记录状态做的。这种方法略显复杂。

###### 绿旗点击锁
###### 变量锁


# 3. 不知道该用什么变量的克隆体

1. 私有变量和私有改动
2. 消息入口的继承
3. 使用消息指数克隆
4. 克隆体克隆自己的退出条件 反向锁
5. 网格锁定和抓取集中
6. 克隆体克隆别的克隆体的队列设置 

# 4. Scratch的谜之容错

1. 不写入数字是计算多少
2. 写入小数的列表提取
3. 造型编号0的问题 颜色和角度的小于零
4. 不写入与或非结果是什么
5. 积木空缺填补参数的强大容错 面向角色的积木块可以加入数字 其实是可以加入字符串来实现
6. 利用容错能做什么 字符\*1等于0 用来判断回答是否为字符 利用数字当成字符串抽出其中的第几位

# 5. 拖慢脚本的罪魁祸首

1. 特效加循环
2. 外形复杂多角色移动



