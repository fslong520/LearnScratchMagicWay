Scratch是积木式的语言（[Blockly](https://github.com/google/blockly)），依靠积木的可连接性来组成代码，防止简单语法错误的发生Scratch分为十种积木，其中形象部分四种：动作、外观、声音、画笔。抽象部分六种：事件、侦测、运算、数据、控制、更多积木。本章将分别介绍所有积木的使用方式和一些易错细节，最后会展开描述所有积木的潜在使用场景。

# 动作

###### 图1. 动作积木总览

Scratch的动作积木可以实现的功能归根结底只有两类：

1. 移动
2. 转向

其中移动类又分为了

1. 直接移动和滑动
2. 增量移动
3. 移动到某角色或者鼠标指针
4. 向面向方向移动

转向类分为了

1. 直接转向
2. 增量转向
3. 面向某角色或鼠标指针

# 直接移动或者转向的模式

相当于指挥角色。直接安排角色到达某个地方面向某个角度。

增量的移动转向或者向面向方向移动，相当于编写角色的内部逻辑。例如设定某小车遇到红色左转30°遇到蓝色右转30°。

# 外观

###### 图2. 外观积木总览

外观控制包括了

1. 角色身上造型切换
2. 外观特效
3. 角色大小设定
4. 说话思考
5. 层叠关系设定
6. 显示隐藏

#### 造型切换

其中造型切换可以传入变量控制，其中变量可以是两种形式：

1. 数字123456...对应了造型的编号
2. 字符串，例如：“造型1”，对应了造型的名称

Scratch都可以自动的识别并找到对应的造型。如果好事者非要把编号为2的造型名称写成1，想看看究竟造型编号和造型名称哪个优先级更高。那么答案是造型名称更高，在“将造型切换为”积木中传入变量1时，名字为“1”的2号造型会显示出来。

#### 外观特效

角色外观的特效分为了好多种类：颜色、鱼眼、旋转、像素化、马赛克、亮度、虚像

其中最有用的是颜色特效，他会在HSB的色轮上，把造型现有的所有颜色都增加固定的数值。例如造型现在是红色，增加颜色特效120会把角色变成蓝色。造型身上如果还有绿色，则会被转换为红色。

我们如果不想制造更多的造型，而想制造一些新鲜感的话，可以对角色的颜色特效进行设定，用一个红色的角色做基础款造型。这样方便我们知道增加颜色特效之后，造型大致会变成什么颜色。

但是这里有个警告：对于不了解Scratch性能的初学者，请减少颜色特效的使用，这几乎是最能拖慢Scratch运行速度的语句。这相当于给正常走路的人背了一大桶水，又要走路又要负重。

第二有用的特效是亮度和虚像，亮度的正值可以增加亮度直到100会变成纯白，负数值直到-100会变成纯黑，虚像特效从0到100分别对应了实体和绝对看不到。

1. 虚像设为100时，角色完全不可见，但是仍旧可以识别碰撞
2. 如果也不想角色识别碰撞，可以直接将角色隐藏

这两种用法会在不同场景派上用场

其他的外观特效使用较少，请读者自行尝试功能，但是要注意的是在使用过外观特效之后一定要使用清楚全部特效，否则很可能会因为设置了虚像而找不到角色。

#### 大小设定

Scratch的舞台大小是480\*360，导入计算机图片作为造型时可以传入不同大小的图片，如果大于Scratch的舞台，软件会自动帮我们把图片缩放到合适尺寸。但是这样可能会造成清晰图片的锯齿化。所以，请合理选择图片的大小。

角色身上的第一个脚本，我们要养成习惯对角色的大小进行设定。而增量大小设定积木可以配合循环模块来动态变化角色的外观。例如可以将角色做成心跳的闪动效果。

###### 图3. 心跳效果实现和变种

#### 说话思考

对于高端玩家来说，说话思考积木，大多数情况下应该只用在调试过程中。可以将变量或者积木块放入说话和思考框之中，让程序在运行过程之中显示中间结果，方便我们调试程序。相当于文本语言中的print，请收好你们说的hello world的冲动。

#### 层叠关系设定

Scratch的层叠关系设定十分迷惑。

设想我们有多个角色，每一个人身上都有一段“当绿旗被点击”“置于最上层”的积木脚本。点击绿旗之后会发生什么情况呢？

大多数人会说不知道，求是的说，Scratch会把你创建顺序在先的“当绿旗被点击”之下的脚本先执行。这是由于这个“当绿旗被点击”积木在Scratch内部被首先注册出来，所以就会首先运行。这种多个脚本同时执行，说穿了只是计算机运行速度很快的假象。在Scratch内核，程序执行还是有顺序的而并非真的并发。

再来设想我们的多个角色身上“当绿旗被点击”的积木下有的跟着“置于最上层”积木，有的跟着“下移1层”，有的跟着“下移2层”....当我们点击绿旗让程序运行，会发生什么？

答案是，虽然我们知道了先拿出来的“当绿旗被点击”积木首先运行，但是由于层级关系太复杂，还是很混乱无法预测。这就是Scratch层叠关系设置欠合理的地方。

所以我们在使用层叠关系时候应该坚持一些原则：

1. 例如尽量不使用多于3层的层叠关系
2. 如果一定要使用多层次关系，那么在设定层级关系时请使用微小的等待时间差距来自己控制层级顺序
3. 对于一直要处在最上层或者最底层的角色，请使用重复执行移到最上层或下移10层的脚本控制角色

###### 图4. 层级关系设置原则

#### 显示隐藏

在角色的属性盘之中，我们也可以设定角色是否显示。且Scratch的显示隐藏还有各类特效和画笔都是记忆状态，换句话说如果某次运行我们让角色隐藏了，那么下次再运行程序，角色还是被隐藏的。这次画的画，如果没有在下次开始时清空就会存留下去。

所以我们如果要使用隐藏积木，请一定记住让显示积木跟在“当绿旗被点击”积木后面。成对使用积木的规律我们要遵守以下三条：

1. 隐藏和显示
2. 外观特效和清除特效
3. 画笔图章和清空

事实上更加广义的来说，这是一个将程序初始化的过程。任何的程序都需要妥善的初始化，你需要做两件事情：

1. 将所有的状态都清空或者设为初始值
2. 将所有定义的变量都赋予一个初始的数值

把所有角色都置于你已知的控制范围内，这是防止程序逐渐庞大后出现奇怪问题的预防针。

# 声音

Scratch声音控制分为两类

1. 角色携带的音轨播放
2. Scratch合成音符播放

#### 播放声音

我们可以把角色携带的声音用积木块播放出来，这主要作用是播放音效，例如吃到金币的音效，被打击的音效等等。我们还可以选择

1. “播放声音”：打开声音就让脚本继续向下执行
2. “播放声音并等待”：打开声音不放完就不往下执行脚本

一般情况下要使用第一种，这样让角色播放音效的时候相当于打开了音乐就继续去做别的事情，不耽误后面的程序运行。但是要注意的是，如果要播放游戏结束音效，我们打开声音后面跟着一个“结束全部”积木，那么声音就听不到了，因为播放声音了之后马上结束了所有脚本的运行。

但是我们又不想播放声音并等待，因为那样会造成角色阵亡了还可以乱动，直到结束音乐播放完毕才可以停下来脚本。这种问题我们有两种解决方案可以参考

1. 使用“播放声音”+“消息”+“结束角色身上其他脚本”积木，消息通知舞台上所有其他人停止。
2. 使用“播放声音并等待”+“消息”+“结束全部”，通知本角色身上关于运动的脚本停止。

#### 播放音符

Scratch的播放音符可以实现打击乐器和乐音乐器两种效果，通过数字编号0到200对应了十二平均律的各种音高。这样我们就可以用变量来控制音符的播放了，这样可以播放我们自己的乐谱。然而Scratch的音符是通过正弦波频率来合成的，低于40编号的音符听上去很奇怪，而且无法实现连续音符的过渡，所有的音符都是单独的，并不能实现什么优美得音乐效果。所以如果想播放音乐，还是使用外部导入音乐来的方便。

# 画笔

Scratch的画笔是角色坐标和外观的延伸。

1. 落笔抬笔指的是在角色中心，也即是角色坐标位置落笔
2. 图章指的是将角色现在的造型印在背景上

需要说明的是：

1. 画笔和图章都直接画在了舞台背景之上，如果有其他角色，将会覆盖画笔的内容。因为舞台在Scratch之中是默认最底层的，不可能有比舞台还底层的东西。
2. 画笔图章和角色隐藏与否无关，隐藏的角色依旧可以画笔和使用图章。
3. 画笔和图章之间是可以互相覆盖的，后画的覆盖先画的。

对于画笔来说，Scratch 3.0之中可以完整的设置色相、饱和度和明度，也即是HSB颜色空间。在Scratch 2.0中我们只能设置画笔颜色为0到200为红橙黄绿青蓝紫的色相，饱和度是固定的。

作为代替，我们可以使用取色器设定画笔颜色积木块来设置其他颜色。不过麻烦在于我们没有办法取Scratch软件外的颜色，除非我们把色卡做成一个角色造型，导入到Scratch之中，然后使用取色器取用颜色。

其实Scratch留有一个RGB的后门的，取色器设定画笔颜色积木块可以放入一个变量。我们可以用这样的方式来控制RGB和透明度Alpha。

###### 图5. 取色器的RGB后门

应用上，画笔大多是和运动控制结合使用的。然而我们总是局限于运动物体速度过慢的情况，这种情况下我们要使用自定义模块的运行不刷新屏幕模式来实现快速画笔。该模式将在自定义模块部分详细介绍。另：截止到写作时间为止，未发布的Scratch 3.0项目之中，使用自定义模块是默认不刷新屏幕的。

# 事件

Scratch之中圆顶的积木称之为脚本入口，也即是当他们等待的条件满足时，就开始下面连接的脚本。Scratch有六大脚本入口

1. 绿旗入口
2. 切换背景入口
3. 角色点击入口
4. 按键入口
5. 声控入口
6. 消息入口

其中前五个入口是可以由人为发起的，最后一个是角色之间互发消息发起的。这里面最常见的绿旗入口我们几乎每天都要用到，但是我们真的了解绿旗入口么？

#### 绿旗入口

我们究竟需要几个绿旗入口？前面在讲解层叠关系时说到了绿旗入口的Scratch内核注册顺序问题。虽然说计算机内部都是顺序执行的，但是我们还是在编写并发程序，也即是说许多绿旗入口在你一次点击之下会集体开始执行。在这种可怕的无法预测的情况下，我们需要做到的是防止两个绿旗入口下的脚本互相干扰。例如一段代码把一个变量改变了一个数值，另一段代码又改回去，一段说要停止程序，另一段却又开始等等。合理的拆分程序到不同的绿旗入口之下是一种必要的程序逻辑训练，如果有条件和耐心，不断地重新编写一个程序，以求更加的清晰和优化，这会极大地有助于编程思维能力的提升。

笔者的计算机课程老师经常教育笔者：如果发现程序错了，全部重新写一次，那将比你试图修改要快的多。而且你将有机会重新审视自己这段程序的逻辑，是最好的训练之一。

我们要坚持的原则是：

1. 把互相无关的东西放在不同的绿旗入口之下。
2. 检查程序流向是否会互相交叉干扰，同一个消息只有一个发送者，同一个变量同时只有一个更改者。

好事者又要提问了，如果同时一定有好多角色可以操作到某个变量，应该怎么办？

答案是，应该加锁，这个过程将在后续章节之中介绍。

#### 切换背景入口

切换背景入口是为了不同关卡的场景切换而生，进入规定关卡则执行该入口下的内容。建议在设计复杂的多关卡游戏时，只在总控制部分放置切换背景更改状态的脚本。如果每个角色身上都带有此类脚本，而背景又经常切换的时候，逻辑将变得及其复杂，调试起来十分痛苦。

#### 角色点击入口

角色的点击入口又要牵涉前文提到过的拖拽角色优先级最高。我们可以尝试简单的放下：当角色被点击则角色大小增加10。在编辑器状态下点击角色，角色将被拖拽起来而不会执行增加大小的积木。在播放器状态下，点击角色可以看到角色增加了大小。

而且更重要的一点是，这个入口是一次性激发的，也即是我们如果在播放器状态下对角色点着鼠标不放，角色大小只会增加一次。要想执行第二次必须松开鼠标按键再次点击。这种防止被多次触发的机制也让该入口成为Scratch最安全的入口之一，当然前提是在播放器状态下。

#### 按键入口

刚才我们讨论了角色被点击入口，大家可能还不能理解入口被多次触发带来的困扰。现在麻烦就要来了。

假设我们要写一段脚本，当向上键被按下时，角色的y坐标增加10。使用如下代码，当我们长按向上键时，可以观察到角色首先向上移动了一下，接着开始快速向上移动，中间发生了一个小的卡顿。好像向上窜了一下才往前移动，控制起来十分不流畅。

###### 图6. 按键入口控制角色移动

为什么会发生这种奇怪的现象？

这是因为Scratch对于积木块执行速度的有特殊的控制。Scratch既想让按键可以单独的控制某个动作，不至于因为单独按键发生了连续执行的效果，又想让按键可以产生连续的控制这个动作。

这种矛盾的做法让按键入口很难作为角色移动的控制。一般来说我们要使用重复执行和侦测判断按键来实现稳定的角色移动控制。代码如下

###### 图7. 重复执行加侦测判断控制角色移动

为什么重复执行价侦测判断的方案就可以稳定的控制角色移动呢？这要从游戏引擎说起了，任何一款用作游戏开发的引擎必然会自带一个执行速度固定的语句。

我们要实现角色以一个固定速度移动，我们只需要让他固定时间长度往前移动固定步数即可。设想这个语句的执行时间不固定，角色的速度也会不固定，这样就没法实现最简单的匀速运动。

熟悉游戏开发的朋友可能知道，在Unity编辑器之中有一个FixUpdate()语句，可是实现固定时间长度的运行。高级的物理引擎也都是基于这个语句实现的。在Scratch之中，为了不把这个问题展示给初学者引起不必要的迷惑，开发者们聪明的将重复执行积木变成了这个固定时间长度语句。也就是循环中间装入不是很多语句的时候，每次循环中间的语句执行完毕的时候还会等一小下，把一次循环的总时长补到大约是0.03s左右（测量并不准确）。

###### 图7. 重复执行时间示意

因此，我们把“重复执行”积木之中放入一个“移动10步”积木，就可以实现角色的移动。究其根本是因为重复执行锁定了每一次执行的时间。

好事者又想问，如果我们往重复执行里面放入许多耗时极长的语句，会不会挤爆重复执行语句？

答案是不会，一旦重复执行之中包含的语句超过了重复执行锁定的时长，













